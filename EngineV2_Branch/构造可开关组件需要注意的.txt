0、是否事先删除了外isOpen()方法
19、保证没有漏掉取出open、close方法中finally字句中的内容
1、启动方法中检查旧的线程是否还在运行
2、写方法是否立即完毕
3、是否还留有thread.interrupt()方法
4、是否初始化了ocs
5、是否补全了以前的异常中的提示字符串
6、是否删除了多余的异常
7、是否删除了给方法加的不需要的开关保护
8、是否更改了阻塞队列
9、是否加上了打开和关闭阻塞队列的方法
10、阻塞队列的打开方法放在启动其他线程前
11、在关闭其它线程前关闭了阻塞队列
12、open、close方法中的语句的顺序安排是否的当
13、取数据的方法在关闭后也可用
14、是否在open方法中清空了所有的成员变量，使它们回到初始状态
15、是否在close方法中没有加上使线程成员变量置为null的语句，以妨碍open中检查线程状态
16、是否记得更改open、close方法
17、是否记得最后加上isOpen方法
18、是否在构造方法中加上了对ocs的初始化，而且没有办法绕过这个构造方法
20、不要忘了加testOpen、testClosed方法
21、检查import是否有错误
22、组件是否都实现了IOpenClosable
23、检查所有的TODO，补全没有做的
24、方法的注释中，过去的关于异常的注释应该改写
25、检查ocs的testOpen没有写成isOpen
26、检查没有错用testClosed
27、在open方法中检查上一次关闭以来，是否线程都已经退出了